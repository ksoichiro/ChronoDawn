// Resource validation task: validates JSON syntax and cross-references in assets
import groovy.json.JsonSlurper
import groovy.json.JsonException

tasks.register('validateResources') {
    group = 'verification'
    description = 'Validates JSON syntax and resource cross-references in assets'

    doLast {
        def resourceDir = file("${rootProject.projectDir}/common/src/main/resources")
        def assetsDir = file("${resourceDir}/assets/chronodawn")
        def errors = []

        // 1. JSON syntax check
        logger.lifecycle("Checking JSON syntax...")
        def jsonSlurper = new JsonSlurper()
        def jsonFiles = fileTree(dir: resourceDir, includes: ['**/*.json'])
        jsonFiles.each { File jsonFile ->
            try {
                jsonSlurper.parseText(jsonFile.text)
            } catch (JsonException e) {
                errors << "JSON syntax error in ${jsonFile.relativePath(resourceDir)}: ${e.message}"
            } catch (Exception e) {
                errors << "Failed to parse ${jsonFile.relativePath(resourceDir)}: ${e.message}"
            }
        }
        logger.lifecycle("  Checked ${jsonFiles.files.size()} JSON files")

        // 2. Blockstate -> model reference check
        logger.lifecycle("Checking blockstate -> model references...")
        def blockstatesDir = file("${assetsDir}/blockstates")
        def modelsBlockDir = file("${assetsDir}/models/block")
        int blockstateRefs = 0
        if (blockstatesDir.exists()) {
            blockstatesDir.eachFileMatch(~/.+\.json/) { File bsFile ->
                try {
                    def bs = jsonSlurper.parseText(bsFile.text)
                    def models = extractModelReferences(bs)
                    models.each { String modelRef ->
                        if (modelRef.startsWith("chronodawn:block/")) {
                            def modelName = modelRef.replace("chronodawn:block/", "")
                            def modelFile = new File(modelsBlockDir, "${modelName}.json")
                            if (!modelFile.exists()) {
                                errors << "Blockstate ${bsFile.name} references model '${modelRef}' but ${modelFile.name} does not exist"
                            }
                            blockstateRefs++
                        }
                    }
                } catch (Exception e) {
                    // JSON syntax errors already caught above
                }
            }
        }
        logger.lifecycle("  Checked ${blockstateRefs} blockstate -> model references")

        // 3. Model -> texture reference check
        logger.lifecycle("Checking model -> texture references...")
        def modelsDir = file("${assetsDir}/models")
        def texturesDir = file("${assetsDir}/textures")
        int textureRefs = 0
        if (modelsDir.exists()) {
            fileTree(dir: modelsDir, includes: ['**/*.json']).each { File modelFile ->
                try {
                    def model = jsonSlurper.parseText(modelFile.text)
                    if (model instanceof Map && model.textures instanceof Map) {
                        model.textures.each { key, value ->
                            if (value instanceof String && value.startsWith("chronodawn:")) {
                                def texturePath = value.replace("chronodawn:", "")
                                def textureFile = new File(texturesDir, "${texturePath}.png")
                                if (!textureFile.exists()) {
                                    def relativePath = modelFile.toPath().relativize(modelsDir.toPath()).toString()
                                    def modelRelative = modelsDir.toPath().relativize(modelFile.toPath()).toString()
                                    errors << "Model ${modelRelative} references texture '${value}' but ${texturePath}.png does not exist"
                                }
                                textureRefs++
                            }
                            // Skip minecraft: prefixed references
                        }
                    }
                } catch (Exception e) {
                    // JSON syntax errors already caught above
                }
            }
        }
        logger.lifecycle("  Checked ${textureRefs} model -> texture references")

        // Report results
        if (errors.isEmpty()) {
            logger.lifecycle("Resource validation passed: all references are valid.")
        } else {
            errors.each { logger.error("  ERROR: ${it}") }
            throw new GradleException("Resource validation failed with ${errors.size()} error(s)")
        }
    }
}

// Cross-version translation validation task
// Validates that all registered entities/items have translations in all versions
tasks.register('validateTranslations') {
    group = 'verification'
    description = 'Validates that translation keys exist across all Minecraft versions'

    doLast {
        def versions = ['1.20.1', '1.21.1', '1.21.2', '1.21.3']
        // Map hotfix versions to their base module version
        def moduleVersionMap = ['1.21.3': '1.21.2']
        def jsonSlurper = new JsonSlurper()
        def errors = []

        // Parse ModEntityId.java to get entity IDs
        def entityIdFile = file("${rootProject.projectDir}/common-shared/src/main/java/com/chronodawn/registry/ModEntityId.java")
        def entityIds = extractEnumValues(entityIdFile)

        // Parse ModItemId.java to get item IDs
        def itemIdFile = file("${rootProject.projectDir}/common-shared/src/main/java/com/chronodawn/registry/ModItemId.java")
        def itemIds = extractEnumValues(itemIdFile)

        // Technical entities that don't need translations
        def excludedEntities = ['gear_projectile', 'time_arrow', 'time_blast']

        logger.lifecycle("Validating translations across ${versions.size()} versions...")
        logger.lifecycle("  Found ${entityIds.size()} entities and ${itemIds.size()} items to validate")

        versions.each { version ->
            def moduleVersion = moduleVersionMap.getOrDefault(version, version)
            def langFile = file("${rootProject.projectDir}/common-${moduleVersion}/src/main/resources/assets/chronodawn/lang/en_us.json")
            if (!langFile.exists()) {
                errors << "[${version}] Language file not found: ${langFile.path}"
                return
            }

            def langMap = jsonSlurper.parseText(langFile.text)

            // Check entity translations
            entityIds.each { entityId ->
                if (excludedEntities.contains(entityId)) return
                // Use toString() to convert GString to String for proper Map key lookup
                def key = "entity.chronodawn.${entityId}".toString()
                if (!langMap.containsKey(key)) {
                    errors << "[${version}] Missing entity translation: ${key}"
                }
            }

            // Check spawn egg translations
            entityIds.each { entityId ->
                if (excludedEntities.contains(entityId)) return
                // Use toString() to convert GString to String for proper Map key lookup
                def key = "item.chronodawn.${entityId}_spawn_egg".toString()
                def spawnEggItemId = "${entityId}_spawn_egg".toString()
                // Only check if the spawn egg item exists in ModItemId
                if (itemIds.contains(spawnEggItemId)) {
                    if (!langMap.containsKey(key)) {
                        errors << "[${version}] Missing spawn egg translation: ${key}"
                    }
                }
            }
        }

        // Report results
        if (errors.isEmpty()) {
            logger.lifecycle("Cross-version translation validation passed.")
        } else {
            logger.lifecycle("")
            errors.each { logger.error("  ERROR: ${it}") }
            throw new GradleException("Translation validation failed with ${errors.size()} error(s)")
        }
    }
}

// Extract enum values from a ModXxxId.java file
// Matches patterns like: ENTITY_NAME("entity_name"),
def extractEnumValues(File file) {
    def ids = []
    if (!file.exists()) {
        return ids
    }
    def content = file.text
    def pattern = ~/(\w+)\s*\(\s*"([^"]+)"\s*\)/
    def matcher = pattern.matcher(content)
    while (matcher.find()) {
        ids << matcher.group(2)  // The string value in parentheses
    }
    return ids
}

// Extract all model references from a blockstate JSON structure
def extractModelReferences(Object node) {
    def models = []
    if (node instanceof Map) {
        node.each { key, value ->
            if (key == "model" && value instanceof String) {
                models << value
            } else {
                models.addAll(extractModelReferences(value))
            }
        }
    } else if (node instanceof List) {
        node.each { item ->
            models.addAll(extractModelReferences(item))
        }
    }
    return models
}
