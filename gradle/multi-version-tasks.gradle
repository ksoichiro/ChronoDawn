// Multi-version build and run tasks (Phase 5: Build Script Enhancement)
// This script defines custom Gradle tasks for building and running the mod
// across multiple Minecraft versions.

// ============================================================
// Build Tasks
// ============================================================

/**
 * Build for Minecraft 1.20.1
 * Usage: ./gradlew build1_20_1
 */
tasks.register('build1_20_1') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.20.1'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.20.1...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.20.1', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.1
 * Usage: ./gradlew build1_21_1
 */
tasks.register('build1_21_1') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.1'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.1...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.1', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.2
 * Usage: ./gradlew build1_21_2
 */
tasks.register('build1_21_2') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.2'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.2...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.2', '-x', 'test'
        }
    }
}

/**
 * Build for all supported Minecraft versions
 * Usage: ./gradlew buildAll
 */
tasks.register('buildAll') {
    group = 'chrono dawn build'
    description = 'Build mod for all supported Minecraft versions (1.20.1, 1.21.1, 1.21.2)'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Building for ALL supported Minecraft versions...')
        logger.lifecycle('Versions: 1.20.1, 1.21.1, 1.21.2')
        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }

    doLast {
        def versions = ['1.20.1', '1.21.1', '1.21.2']
        def failed = []

        versions.each { version ->
            logger.lifecycle('')
            logger.lifecycle(">>> Building for Minecraft ${version}...")
            logger.lifecycle('')

            try {
                project.exec {
                    commandLine './gradlew', 'clean', 'build', "-Ptarget_mc_version=${version}", '-x', 'test'
                    errorOutput = System.err
                }
                logger.lifecycle("SUCCESS: Minecraft ${version}")
            } catch (Exception e) {
                logger.error("FAILED: Minecraft ${version}")
                failed.add(version)
            }
        }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Build Summary:')
        logger.lifecycle('====================================================')

        if (failed.isEmpty()) {
            logger.lifecycle('All versions built successfully!')
            versions.each { version ->
                logger.lifecycle("   - Minecraft ${version}")
            }
        } else {
            logger.lifecycle("${failed.size()} version(s) failed:")
            failed.each { version ->
                logger.lifecycle("   - Minecraft ${version}")
            }
            throw new GradleException("Build failed for: ${failed.join(', ')}")
        }

        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }
}

// ============================================================
// Run Client Tasks (convenience shortcuts)
// ============================================================

def runClientConfigurations = [
    [version: '1.20.1', loaders: ['fabric']],
    [version: '1.21.1', loaders: ['fabric', 'neoforge']],
    [version: '1.21.2', loaders: ['fabric', 'neoforge']],
]

runClientConfigurations.each { config ->
    def versionSuffix = config.version.replace('.', '_')

    config.loaders.each { loader ->
        def loaderName = loader == 'neoforge' ? 'NeoForge' : loader.capitalize()
        def taskName = "runClient${loaderName}${versionSuffix}"

        tasks.register(taskName) {
            group = 'chrono dawn run'
            description = "Run ${loaderName} client for Minecraft ${config.version}"

            doLast {
                def gradlew = new File(projectDir, 'gradlew').absolutePath
                def cmd = [
                    gradlew,
                    ':' + loader + ':runClient',
                    '-Ptarget_mc_version=' + config.version,
                ] as List<String>

                def pb = new ProcessBuilder(cmd)
                pb.directory(projectDir)
                pb.inheritIO()

                def process = pb.start()
                def exitCode = process.waitFor()
                if (exitCode != 0) {
                    throw new GradleException("${loader} client for ${config.version} exited with code ${exitCode}")
                }
            }
        }
    }
}

// ============================================================
// GameTest Tasks
// ============================================================

/**
 * Run GameTests for all supported Minecraft versions and loaders
 * Usage: ./gradlew gameTestAll
 *
 * Configurations are grouped by Minecraft version (3 parallel threads):
 *   Thread 1: :fabric:runGameTest (1.20.1)
 *   Thread 2: :fabric:runGameTest + :neoforge:runGameTestServer (1.21.1)
 *   Thread 3: :fabric:runGameTest + :neoforge:runGameTestServer (1.21.2)
 *
 * Within each version group, loaders run in a single Gradle process with
 * --parallel to avoid concurrent builds of the shared common module.
 * Each subprocess uses --project-cache-dir to isolate from the outer process.
 *
 * Log files are saved to build/gametest-<version>.log for debugging.
 */
tasks.register('gameTestAll') {
    group = 'chrono dawn test'
    description = 'Run GameTests for all supported Minecraft versions and loaders'

    doLast {
        // Group by version to avoid concurrent builds of the same common module.
        // Within each version, fabric and neoforge run in a single Gradle process
        // (with --parallel) so Gradle properly orders task dependencies.
        // Different versions run as separate processes in parallel since they use
        // entirely separate build directories and common modules.
        def versionGroups = [
            [version: '1.20.1', tasks: [':fabric:runGameTest']],
            [version: '1.21.1', tasks: [':fabric:runGameTest', ':neoforge:runGameTestServer']],
            [version: '1.21.2', tasks: [':fabric:runGameTest', ':neoforge:runGameTestServer']],
        ]

        def passed = java.util.Collections.synchronizedList([])
        def failed = java.util.Collections.synchronizedList([])

        def gradlew = new File(projectDir, 'gradlew').absolutePath
        def logDir = new File(projectDir, 'build')
        logDir.mkdirs()

        def threads = []

        versionGroups.each { group ->
            def version = group.version
            def label = version

            logger.lifecycle(">>> Starting GameTests: version ${version}...")

            def thread = new Thread({
                def cmd = [gradlew]
                cmd.addAll(group.tasks)
                cmd.addAll([
                    '-Ptarget_mc_version=' + version,
                    '--project-cache-dir', '.gradle/gametest-' + version,
                    '--parallel',
                    '--stacktrace'
                ])

                def logFile = new File(logDir, 'gametest-' + version + '.log')

                // Clean stale world directories to avoid session.lock conflicts
                ['fabric', 'neoforge'].each { loader ->
                    def worldDir = new File(projectDir, loader + '-' + version + '/run/world')
                    if (worldDir.exists()) {
                        worldDir.deleteDir()
                    }
                }

                try {
                    def pb = new ProcessBuilder(cmd)
                    pb.directory(projectDir)
                    pb.redirectErrorStream(true)
                    pb.redirectOutput(logFile)

                    def process = pb.start()
                    def exitCode = process.waitFor()

                    if (exitCode == 0) {
                        // Extract loader names for reporting
                        group.tasks.each { task ->
                            def loader = task.split(':')[1]
                            passed.add(loader + ' ' + version)
                        }
                    } else {
                        group.tasks.each { task ->
                            def loader = task.split(':')[1]
                            failed.add(loader + ' ' + version + ' (see ' + logFile.absolutePath + ')')
                        }
                    }
                } catch (Exception e) {
                    failed.add(version + ' (' + e.message + ')')
                }
            }, 'gametest-' + version)

            thread.start()
            threads.add(thread)
        }

        // Wait for all threads to complete
        threads.each { it.join() }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('GameTest Summary:')
        logger.lifecycle('====================================================')

        passed.sort().each { label ->
            logger.lifecycle("   PASSED: ${label}")
        }
        failed.sort().each { entry ->
            logger.lifecycle("   FAILED: ${entry}")
        }

        logger.lifecycle('')
        logger.lifecycle("Total: ${passed.size()} passed, ${failed.size()} failed")
        logger.lifecycle("Logs: ${logDir.absolutePath}/gametest-*.log")
        logger.lifecycle('====================================================')
        logger.lifecycle('')

        if (!failed.isEmpty()) {
            throw new GradleException("GameTests failed for: ${failed.collect { it.split(' \\(')[0] }.join(', ')}")
        }
    }
}
