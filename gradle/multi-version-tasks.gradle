// Multi-version build and run tasks (Phase 5: Build Script Enhancement)
// This script defines custom Gradle tasks for building and running the mod
// across multiple Minecraft versions.

// ============================================================
// Clean Tasks
// ============================================================

/**
 * Clean for Minecraft 1.20.1
 * Usage: ./gradlew clean1_20_1
 */
tasks.register('clean1_20_1') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for Minecraft 1.20.1'

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', '-Ptarget_mc_version=1.20.1'
        }
    }
}

/**
 * Clean for Minecraft 1.21.1
 * Usage: ./gradlew clean1_21_1
 */
tasks.register('clean1_21_1') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for Minecraft 1.21.1'

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', '-Ptarget_mc_version=1.21.1'
        }
    }
}

/**
 * Clean for Minecraft 1.21.2
 * Usage: ./gradlew clean1_21_2
 */
tasks.register('clean1_21_2') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for Minecraft 1.21.2'

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', '-Ptarget_mc_version=1.21.2'
        }
    }
}

/**
 * Clean for Minecraft 1.21.3
 * Usage: ./gradlew clean1_21_3
 * Note: 1.21.3 shares modules with 1.21.2 (hotfix release)
 */
tasks.register('clean1_21_3') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for Minecraft 1.21.3'

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', '-Ptarget_mc_version=1.21.3'
        }
    }
}

/**
 * Clean for Minecraft 1.21.4
 * Usage: ./gradlew clean1_21_4
 */
tasks.register('clean1_21_4') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for Minecraft 1.21.4'

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', '-Ptarget_mc_version=1.21.4'
        }
    }
}

/**
 * Clean for Minecraft 1.21.5
 * Usage: ./gradlew clean1_21_5
 */
tasks.register('clean1_21_5') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for Minecraft 1.21.5'

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', '-Ptarget_mc_version=1.21.5'
        }
    }
}

/**
 * Clean for Minecraft 1.21.6
 * Usage: ./gradlew clean1_21_6
 */
tasks.register('clean1_21_6') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for Minecraft 1.21.6'

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', '-Ptarget_mc_version=1.21.6'
        }
    }
}

/**
 * Clean for all supported Minecraft versions
 * Usage: ./gradlew cleanAll
 *
 * Note: 1.21.3 is excluded because it shares modules with 1.21.2.
 * Cleaning 1.21.2 also cleans the modules used by 1.21.3.
 */
tasks.register('cleanAll') {
    group = 'chrono dawn build'
    description = 'Clean build outputs for all supported Minecraft versions (1.20.1, 1.21.1, 1.21.2, 1.21.4, 1.21.5, 1.21.6)'

    doLast {
        def versions = ['1.20.1', '1.21.1', '1.21.2', '1.21.4', '1.21.5', '1.21.6']

        versions.each { version ->
            logger.lifecycle(">>> Cleaning for Minecraft ${version}...")

            project.exec {
                commandLine './gradlew', 'clean', "-Ptarget_mc_version=${version}"
            }
        }

        // Clean IDE-generated bin/ directories that can interfere with builds/tests
        // (e.g., IntelliJ/Eclipse output directories with unprocessed placeholders)
        def subprojects = [
            'common-1.20.1', 'common-1.21.1', 'common-1.21.2', 'common-1.21.4', 'common-1.21.5', 'common-1.21.6',
            'fabric-1.20.1', 'fabric-1.21.1', 'fabric-1.21.2', 'fabric-1.21.4', 'fabric-1.21.5', 'fabric-1.21.6',
            'neoforge-1.21.1', 'neoforge-1.21.2', 'neoforge-1.21.4', 'neoforge-1.21.5', 'neoforge-1.21.6'
        ]
        def deletedCount = 0
        subprojects.each { subdir ->
            def binDir = file("${subdir}/bin")
            if (binDir.exists()) {
                logger.lifecycle(">>> Deleting IDE-generated directory: ${binDir}")
                delete binDir
                deletedCount++
            }
        }
        if (deletedCount > 0) {
            logger.lifecycle(">>> Deleted ${deletedCount} IDE-generated bin/ directories")
        }

        // Clean Architectury Transformer runtime caches in run directories
        // These caches can cause "Unresolved compilation problems" errors when
        // stale transformed classes remain after code changes
        def runDirs = [
            'fabric-1.20.1/run', 'fabric-1.21.1/run', 'fabric-1.21.2/run', 'fabric-1.21.4/run', 'fabric-1.21.5/run', 'fabric-1.21.6/run',
            'neoforge-1.21.1/run', 'neoforge-1.21.2/run', 'neoforge-1.21.4/run', 'neoforge-1.21.5/run', 'neoforge-1.21.6/run'
        ]
        def transformerDeletedCount = 0
        runDirs.each { runDir ->
            def transformerDir = file("${runDir}/.architectury-transformer")
            if (transformerDir.exists()) {
                logger.lifecycle(">>> Deleting Architectury Transformer cache: ${transformerDir}")
                delete transformerDir
                transformerDeletedCount++
            }
        }
        if (transformerDeletedCount > 0) {
            logger.lifecycle(">>> Deleted ${transformerDeletedCount} Architectury Transformer cache directories")
        }

        logger.lifecycle('')
        logger.lifecycle('All versions cleaned successfully.')
    }
}

// ============================================================
// Build Tasks
// ============================================================

/**
 * Build for Minecraft 1.20.1
 * Usage: ./gradlew build1_20_1
 */
tasks.register('build1_20_1') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.20.1'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.20.1...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.20.1', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.1
 * Usage: ./gradlew build1_21_1
 */
tasks.register('build1_21_1') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.1'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.1...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.1', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.2
 * Usage: ./gradlew build1_21_2
 */
tasks.register('build1_21_2') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.2'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.2...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.2', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.3
 * Usage: ./gradlew build1_21_3
 * Note: 1.21.3 shares modules with 1.21.2 (hotfix release)
 */
tasks.register('build1_21_3') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.3'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.3...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.3', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.4
 * Usage: ./gradlew build1_21_4
 */
tasks.register('build1_21_4') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.4'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.4...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.4', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.5
 * Usage: ./gradlew build1_21_5
 */
tasks.register('build1_21_5') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.5'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.5...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.5', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.6
 * Usage: ./gradlew build1_21_6
 */
tasks.register('build1_21_6') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.6'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.6...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.6', '-x', 'test'
        }
    }
}

/**
 * Build for all supported Minecraft versions (for release)
 * Usage: ./gradlew buildAll
 *
 * Note: 1.21.3 is excluded because it shares modules with 1.21.2.
 * The 1.21.2 JAR files are compatible with Minecraft 1.21.3.
 * Use gameTestAll to verify 1.21.3 runtime compatibility.
 */
tasks.register('buildAll') {
    group = 'chrono dawn build'
    description = 'Build mod for all supported Minecraft versions (1.20.1, 1.21.1, 1.21.2, 1.21.4, 1.21.5, 1.21.6) - for release'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Building for ALL supported Minecraft versions...')
        logger.lifecycle('Versions: 1.20.1, 1.21.1, 1.21.2, 1.21.4, 1.21.5, 1.21.6')
        logger.lifecycle('(1.21.3 excluded - uses 1.21.2 JAR files)')
        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }

    doLast {
        def versions = ['1.20.1', '1.21.1', '1.21.2', '1.21.4', '1.21.5', '1.21.6']
        def failed = []

        versions.each { version ->
            logger.lifecycle('')
            logger.lifecycle(">>> Building for Minecraft ${version}...")
            logger.lifecycle('')

            try {
                project.exec {
                    commandLine './gradlew', 'clean', 'build', "-Ptarget_mc_version=${version}", '-x', 'test'
                    errorOutput = System.err
                }
                logger.lifecycle("SUCCESS: Minecraft ${version}")
            } catch (Exception e) {
                logger.error("FAILED: Minecraft ${version}")
                failed.add(version)
            }
        }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Build Summary:')
        logger.lifecycle('====================================================')

        if (failed.isEmpty()) {
            logger.lifecycle('All versions built successfully!')
            versions.each { version ->
                logger.lifecycle("   - Minecraft ${version}")
            }
        } else {
            logger.lifecycle("${failed.size()} version(s) failed:")
            failed.each { version ->
                logger.lifecycle("   - Minecraft ${version}")
            }
            throw new GradleException("Build failed for: ${failed.join(', ')}")
        }

        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }
}

// ============================================================
// Run Client Tasks (convenience shortcuts)
// ============================================================

def runClientConfigurations = [
    [version: '1.20.1', loaders: ['fabric']],
    [version: '1.21.1', loaders: ['fabric', 'neoforge']],
    [version: '1.21.2', loaders: ['fabric', 'neoforge']],
    [version: '1.21.3', loaders: ['fabric', 'neoforge']],
    [version: '1.21.4', loaders: ['fabric', 'neoforge']],
    [version: '1.21.5', loaders: ['fabric', 'neoforge']],
    [version: '1.21.6', loaders: ['fabric', 'neoforge']],
]

runClientConfigurations.each { config ->
    def versionSuffix = config.version.replace('.', '_')

    config.loaders.each { loader ->
        def loaderName = loader == 'neoforge' ? 'NeoForge' : loader.capitalize()
        def taskName = "runClient${loaderName}${versionSuffix}"

        tasks.register(taskName) {
            group = 'chrono dawn run'
            description = "Run ${loaderName} client for Minecraft ${config.version}"

            doLast {
                def gradlew = new File(projectDir, 'gradlew').absolutePath
                def cmd = [
                    gradlew,
                    ':' + loader + ':runClient',
                    '-Ptarget_mc_version=' + config.version,
                ] as List<String>

                def pb = new ProcessBuilder(cmd)
                pb.directory(projectDir)
                pb.redirectErrorStream(true)

                def process = pb.start()

                // Forward output preserving ANSI escape sequences
                def outputThread = Thread.start {
                    def is = process.inputStream
                    def buf = new byte[8192]
                    int len
                    while ((len = is.read(buf)) != -1) {
                        System.out.write(buf, 0, len)
                        System.out.flush()
                    }
                }

                def exitCode = process.waitFor()
                outputThread.join()
                if (exitCode != 0) {
                    throw new GradleException("${loader} client for ${config.version} exited with code ${exitCode}")
                }
            }
        }
    }
}

// ============================================================
// Test Tasks
// ============================================================

/**
 * Run unit tests for all supported Minecraft versions
 * Usage: ./gradlew testAll
 *
 * Runs only common module JUnit tests (not GameTests).
 * GameTests are run separately via gameTestAll.
 *
 * Note: 1.21.3 is excluded because it shares modules with 1.21.2.
 * Running tests for 1.21.2 covers the same code used by 1.21.3.
 */
tasks.register('testAll') {
    group = 'chrono dawn test'
    description = 'Run unit tests for all supported Minecraft versions (1.20.1, 1.21.1, 1.21.2, 1.21.4, 1.21.5, 1.21.6)'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Running unit tests for ALL supported Minecraft versions...')
        logger.lifecycle('Versions: 1.20.1, 1.21.1, 1.21.2, 1.21.4, 1.21.5, 1.21.6')
        logger.lifecycle('(1.21.3 excluded - shares modules with 1.21.2)')
        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }

    doLast {
        def versions = ['1.20.1', '1.21.1', '1.21.2', '1.21.4', '1.21.5', '1.21.6']
        def failed = []

        versions.each { version ->
            logger.lifecycle('')
            logger.lifecycle(">>> Running unit tests for Minecraft ${version}...")
            logger.lifecycle('')

            try {
                project.exec {
                    commandLine './gradlew', ":common-${version}:test", "-Ptarget_mc_version=${version}"
                    errorOutput = System.err
                }
                logger.lifecycle("SUCCESS: Minecraft ${version}")
            } catch (Exception e) {
                logger.error("FAILED: Minecraft ${version}")
                failed.add(version)
            }
        }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Unit Test Summary:')
        logger.lifecycle('====================================================')

        if (failed.isEmpty()) {
            logger.lifecycle('All versions passed!')
            versions.each { version ->
                logger.lifecycle("   - Minecraft ${version}")
            }
        } else {
            logger.lifecycle("${failed.size()} version(s) failed:")
            failed.each { version ->
                logger.lifecycle("   - Minecraft ${version}")
            }
            throw new GradleException("Unit tests failed for: ${failed.join(', ')}")
        }

        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }
}

// ============================================================
// GameTest Tasks
// ============================================================

/**
 * Run all verification tasks: cleanAll, validateResources, validateTranslations, buildAll, testAll, gameTestAll
 * Usage: ./gradlew checkAll
 *
 * This is the comprehensive verification task that runs all checks in sequence:
 *   1. cleanAll - Clean all build outputs and IDE-generated directories
 *   2. validateResources - JSON syntax and cross-reference validation
 *   3. validateTranslations - Cross-version translation key validation
 *   4. buildAll - Build for all Minecraft versions (1.20.1, 1.21.1, 1.21.2, 1.21.4, 1.21.5)
 *   5. testAll - Run unit tests for all versions (1.20.1, 1.21.1, 1.21.2, 1.21.4, 1.21.5)
 *   6. gameTestAll - Run GameTests for all versions including 1.21.3/1.21.4/1.21.5 runtime
 *
 * Note: 1.21.3 is only tested via gameTestAll (runtime verification).
 * Build/unit tests use 1.21.2 modules which are compatible with 1.21.3.
 *
 * If any step fails, subsequent steps are skipped and the task fails.
 */
tasks.register('checkAll') {
    group = 'chrono dawn verification'
    description = 'Run all verification tasks: cleanAll, validateResources, validateTranslations, buildAll, testAll, gameTestAll'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Running ALL verification tasks...')
        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }

    doLast {
        def steps = [
            [name: 'cleanAll', task: 'cleanAll'],
            [name: 'validateResources', task: 'validateResources'],
            [name: 'validateTranslations', task: 'validateTranslations'],
            [name: 'buildAll', task: 'buildAll'],
            [name: 'testAll', task: 'testAll'],
            [name: 'gameTestAll', task: 'gameTestAll'],
        ]

        def passed = []
        def failed = null

        steps.each { step ->
            if (failed != null) {
                logger.lifecycle(">>> Skipping ${step.name} (previous step failed)")
                return
            }

            logger.lifecycle('')
            logger.lifecycle(">>> Running ${step.name}...")
            logger.lifecycle('')

            try {
                project.exec {
                    commandLine './gradlew', step.task
                    errorOutput = System.err
                }
                passed.add(step.name)
                logger.lifecycle("SUCCESS: ${step.name}")
            } catch (Exception e) {
                failed = step.name
                logger.error("FAILED: ${step.name}")
            }
        }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Verification Summary:')
        logger.lifecycle('====================================================')

        passed.each { name ->
            logger.lifecycle("   PASSED: ${name}")
        }
        if (failed != null) {
            logger.lifecycle("   FAILED: ${failed}")
            def skipped = steps.findAll { s -> !passed.contains(s.name) && s.name != failed }
            skipped.each { s ->
                logger.lifecycle("   SKIPPED: ${s.name}")
            }
        }

        logger.lifecycle('')
        logger.lifecycle("Total: ${passed.size()} passed, ${failed != null ? 1 : 0} failed, ${steps.size() - passed.size() - (failed != null ? 1 : 0)} skipped")
        logger.lifecycle('====================================================')
        logger.lifecycle('')

        if (failed != null) {
            throw new GradleException("Verification failed at: ${failed}")
        }

        logger.lifecycle('All verification tasks passed!')
    }
}

// ============================================================
// Release Tasks
// ============================================================

/**
 * Collect release JARs from all versions into build/release/
 * Usage: ./gradlew collectJars
 *
 * Looks for built JARs in each platform-version build/libs/ directory
 * and copies them to a centralized build/release/ directory.
 */
tasks.register('collectJars') {
    group = 'chrono dawn build'
    description = 'Collect release JARs from all versions into build/release/'

    doLast {
        def releaseDir = file("${rootDir}/build/release")
        if (releaseDir.exists()) {
            releaseDir.deleteDir()
        }
        releaseDir.mkdirs()

        def collected = []
        def versions = ['1.20.1', '1.21.1', '1.21.2', '1.21.4', '1.21.5', '1.21.6']
        def platforms = ['fabric', 'neoforge']

        def archivesName = project.property('archives_name')
        def modVersion = project.property('mod_version')

        versions.each { version ->
            platforms.each { platform ->
                def libsDir = file("${rootDir}/${platform}-${version}/build/libs")
                if (!libsDir.exists()) {
                    logger.warn("SKIP: ${libsDir} does not exist (not built yet?)")
                    return
                }

                def jarName = "${archivesName}-${modVersion}+${version}-${platform}.jar"
                def jarFile = new File(libsDir, jarName)

                if (jarFile.exists()) {
                    ant.copy(file: jarFile, todir: releaseDir)
                    collected.add(jarName)
                    logger.lifecycle("Collected: ${jarName}")
                } else {
                    logger.warn("NOT FOUND: ${jarFile}")
                }
            }
        }

        logger.lifecycle('')
        if (collected.isEmpty()) {
            logger.warn('No release JARs found. Run buildAll first.')
        } else {
            logger.lifecycle("${collected.size()} JAR(s) collected into build/release/")
        }
    }
}

/**
 * Full release: cleanAll, buildAll, collectJars
 * Usage: ./gradlew release
 *
 * Runs the full release pipeline in sequence:
 *   1. cleanAll - Clean all build outputs
 *   2. buildAll - Build for all Minecraft versions
 *   3. collectJars - Collect JARs into build/release/
 */
tasks.register('release') {
    group = 'chrono dawn build'
    description = 'Full release: cleanAll, buildAll, collectJars'

    doLast {
        def steps = ['cleanAll', 'buildAll', 'collectJars']

        steps.each { step ->
            logger.lifecycle('')
            logger.lifecycle(">>> Running ${step}...")
            logger.lifecycle('')

            project.exec {
                commandLine './gradlew', step
                errorOutput = System.err
            }
        }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Release build completed!')
        logger.lifecycle('JARs collected in: build/release/')
        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }
}

/**
 * Run GameTests for all supported Minecraft versions and loaders
 * Usage: ./gradlew gameTestAll
 *
 * Configurations are grouped by Minecraft version (4 parallel threads):
 *   Thread 1: :fabric:runGameTest (1.20.1)
 *   Thread 2: :fabric:runGameTest + :neoforge:runGameTestServer (1.21.1)
 *   Thread 3: :fabric:runGameTest + :neoforge:runGameTestServer (1.21.2, then 1.21.3)
 *   Thread 4: :fabric:runGameTest + :neoforge:runGameTestServer (1.21.4)
 *
 * Note: 1.21.2 and 1.21.3 share the same modules (1.21.3 is a hotfix release),
 * so they run sequentially in the same thread to avoid build conflicts.
 *
 * Within each version group, loaders run in a single Gradle process with
 * --parallel to avoid concurrent builds of the shared common module.
 * Each subprocess uses --project-cache-dir to isolate from the outer process.
 *
 * Log files are saved to build/gametest-<version>.log for debugging.
 */
tasks.register('gameTestAll') {
    group = 'chrono dawn test'
    description = 'Run GameTests for all supported Minecraft versions and loaders'

    doLast {
        // Group by version to avoid concurrent builds of the same common module.
        // Within each version, fabric and neoforge run in a single Gradle process
        // (with --parallel) so Gradle properly orders task dependencies.
        // Different versions run as separate processes in parallel since they use
        // entirely separate build directories and common modules.
        // Note: 1.21.2 and 1.21.3 share the same modules, so they run sequentially.
        def versionGroups = [
            [versions: ['1.20.1'], tasks: [':fabric:runGameTest']],
            [versions: ['1.21.1'], tasks: [':fabric:runGameTest', ':neoforge:runGameTestServer']],
            // 1.21.2 and 1.21.3 share the same modules, so run sequentially in one thread
            [versions: ['1.21.2', '1.21.3'], tasks: [':fabric:runGameTest', ':neoforge:runGameTestServer']],
            [versions: ['1.21.4'], tasks: [':fabric:runGameTest', ':neoforge:runGameTestServer']],
            [versions: ['1.21.5'], tasks: [':fabric:runGameTest', ':neoforge:runGameTestServer']],
            [versions: ['1.21.6'], tasks: [':fabric:runGameTest', ':neoforge:runGameTestServer']],
        ]

        // Map hotfix versions to their base module version for directory paths
        def moduleVersionMap = ['1.21.3': '1.21.2']

        def passed = java.util.Collections.synchronizedList([])
        def failed = java.util.Collections.synchronizedList([])

        def gradlew = new File(projectDir, 'gradlew').absolutePath
        def logDir = new File(projectDir, 'build')
        logDir.mkdirs()

        def threads = []

        versionGroups.each { group ->
            def groupLabel = group.versions.join('+')

            logger.lifecycle(">>> Starting GameTests: versions ${groupLabel}...")

            def thread = new Thread({
                // Run each version in the group sequentially
                group.versions.each { version ->
                    def moduleVersion = moduleVersionMap.getOrDefault(version, version)

                    def cmd = [gradlew]
                    cmd.addAll(group.tasks)
                    cmd.addAll([
                        '-Ptarget_mc_version=' + version,
                        '--project-cache-dir', '.gradle/gametest-' + version,
                        '--parallel',
                        '--stacktrace'
                    ])

                    def logFile = new File(logDir, 'gametest-' + version + '.log')

                    // Clean stale world directories to avoid session.lock conflicts
                    // Use moduleVersion for directory path (1.21.3 uses fabric-1.21.2)
                    ['fabric', 'neoforge'].each { loader ->
                        def worldDir = new File(projectDir, loader + '-' + moduleVersion + '/run/world')
                        if (worldDir.exists()) {
                            worldDir.deleteDir()
                        }
                    }

                    try {
                        def pb = new ProcessBuilder(cmd)
                        pb.directory(projectDir)
                        pb.redirectErrorStream(true)
                        pb.redirectOutput(logFile)

                        def process = pb.start()
                        def exitCode = process.waitFor()

                        if (exitCode == 0) {
                            // Extract loader names for reporting
                            group.tasks.each { task ->
                                def loader = task.split(':')[1]
                                passed.add(loader + ' ' + version)
                            }
                        } else {
                            group.tasks.each { task ->
                                def loader = task.split(':')[1]
                                failed.add(loader + ' ' + version + ' (see ' + logFile.absolutePath + ')')
                            }
                        }
                    } catch (Exception e) {
                        failed.add(version + ' (' + e.message + ')')
                    }
                }
            }, 'gametest-' + groupLabel)

            thread.start()
            threads.add(thread)
        }

        // Wait for all threads to complete
        threads.each { it.join() }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('GameTest Summary:')
        logger.lifecycle('====================================================')

        passed.sort().each { label ->
            logger.lifecycle("   PASSED: ${label}")
        }
        failed.sort().each { entry ->
            logger.lifecycle("   FAILED: ${entry}")
        }

        logger.lifecycle('')
        logger.lifecycle("Total: ${passed.size()} passed, ${failed.size()} failed")
        logger.lifecycle("Logs: ${logDir.absolutePath}/gametest-*.log")
        logger.lifecycle('====================================================')
        logger.lifecycle('')

        if (!failed.isEmpty()) {
            throw new GradleException("GameTests failed for: ${failed.collect { it.split(' \\(')[0] }.join(', ')}")
        }
    }
}
