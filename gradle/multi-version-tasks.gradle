// Multi-version build and run tasks (Phase 5: Build Script Enhancement)
// This script defines custom Gradle tasks for building and running the mod
// across multiple Minecraft versions.

// ============================================================
// Build Tasks
// ============================================================

/**
 * Build for Minecraft 1.20.1
 * Usage: ./gradlew build1_20_1
 */
tasks.register('build1_20_1') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.20.1'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.20.1...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.20.1', '-x', 'test'
        }
    }
}

/**
 * Build for Minecraft 1.21.1
 * Usage: ./gradlew build1_21_1
 */
tasks.register('build1_21_1') {
    group = 'chrono dawn build'
    description = 'Build mod for Minecraft 1.21.1'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================')
        logger.lifecycle('Building for Minecraft 1.21.1...')
        logger.lifecycle('====================================')
        logger.lifecycle('')
    }

    doLast {
        project.exec {
            commandLine './gradlew', 'clean', 'build', '-Ptarget_mc_version=1.21.1', '-x', 'test'
        }
    }
}

/**
 * Build for all supported Minecraft versions
 * Usage: ./gradlew buildAll
 */
tasks.register('buildAll') {
    group = 'chrono dawn build'
    description = 'Build mod for all supported Minecraft versions (1.20.1, 1.21.1)'

    doFirst {
        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Building for ALL supported Minecraft versions...')
        logger.lifecycle('Versions: 1.20.1, 1.21.1')
        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }

    doLast {
        def versions = ['1.20.1', '1.21.1']
        def failed = []

        versions.each { version ->
            logger.lifecycle('')
            logger.lifecycle(">>> Building for Minecraft ${version}...")
            logger.lifecycle('')

            try {
                project.exec {
                    commandLine './gradlew', 'clean', 'build', "-Ptarget_mc_version=${version}"
                    errorOutput = System.err
                }
                logger.lifecycle("✅ SUCCESS: Minecraft ${version}")
            } catch (Exception e) {
                logger.error("❌ FAILED: Minecraft ${version}")
                failed.add(version)
            }
        }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('Build Summary:')
        logger.lifecycle('====================================================')

        if (failed.isEmpty()) {
            logger.lifecycle('✅ All versions built successfully!')
            logger.lifecycle("   - Minecraft 1.20.1")
            logger.lifecycle("   - Minecraft 1.21.1")
        } else {
            logger.lifecycle("❌ ${failed.size()} version(s) failed:")
            failed.each { version ->
                logger.lifecycle("   - Minecraft ${version}")
            }
            throw new GradleException("Build failed for: ${failed.join(', ')}")
        }

        logger.lifecycle('====================================================')
        logger.lifecycle('')
    }
}

// ============================================================
// GameTest Tasks
// ============================================================

/**
 * Run GameTests for all supported Minecraft versions and loaders
 * Usage: ./gradlew gameTestAll
 *
 * Runs in parallel groups (fabric + neoforge can run concurrently since they
 * use separate .gradle/architectury/ directories for runtime transformer config).
 * Within the same platform, versions run sequentially to avoid .gradle/architectury/
 * file conflicts (paths are hardcoded in Architectury Plugin with no API to override).
 *
 * Each process uses -PbuildDirSuffix to isolate build output directories,
 * eliminating the need for 'clean' between runs.
 *
 * Groups:
 *   1. fabric 1.20.1 || neoforge 1.21.1
 *   2. fabric 1.21.1 || neoforge 1.21.2
 *   3. fabric 1.21.2
 *
 * Individual log files are saved to build/gametest-*.log for debugging.
 */
tasks.register('gameTestAll') {
    group = 'chrono dawn test'
    description = 'Run GameTests for all supported Minecraft versions and loaders'

    doLast {
        // Each group contains configs that can run in parallel (different platforms).
        // Groups run sequentially (same platform must not overlap due to
        // .gradle/architectury/ path being hardcoded in Architectury Plugin).
        def groups = [
            [
                [loader: 'fabric', task: 'runGameTest', version: '1.20.1'],
                [loader: 'neoforge', task: 'runGameTestServer', version: '1.21.1'],
            ],
            [
                [loader: 'fabric', task: 'runGameTest', version: '1.21.1'],
                [loader: 'neoforge', task: 'runGameTestServer', version: '1.21.2'],
            ],
            [
                [loader: 'fabric', task: 'runGameTest', version: '1.21.2'],
            ],
        ]

        def passed = java.util.Collections.synchronizedList([])
        def failed = java.util.Collections.synchronizedList([])

        def gradlew = new File(projectDir, 'gradlew').absolutePath
        def logDir = new File(projectDir, 'build')
        logDir.mkdirs()

        groups.eachWithIndex { group, groupIdx ->
            logger.lifecycle('')
            logger.lifecycle("--- Group ${groupIdx + 1}/${groups.size()} ---")

            def threads = []

            group.each { config ->
                def label = config.loader + ' ' + config.version
                def suffix = config.version + '-' + config.loader

                logger.lifecycle(">>> Starting GameTests: ${label}...")

                def thread = new Thread({
                    def cmd = [
                        gradlew,
                        ':' + config.loader + ':' + config.task,
                        '-Ptarget_mc_version=' + config.version,
                        '-PbuildDirSuffix=' + suffix,
                        '--parallel',
                        '--stacktrace'
                    ] as List<String>

                    def logFile = new File(logDir, 'gametest-' + suffix + '.log')

                    try {
                        def pb = new ProcessBuilder(cmd)
                        pb.directory(projectDir)
                        pb.redirectErrorStream(true)
                        pb.redirectOutput(logFile)

                        def process = pb.start()
                        def exitCode = process.waitFor()

                        if (exitCode == 0) {
                            passed.add(label)
                        } else {
                            failed.add(label + ' (see ' + logFile.absolutePath + ')')
                        }
                    } catch (Exception e) {
                        failed.add(label + ' (' + e.message + ')')
                    }
                }, 'gametest-' + suffix)

                thread.start()
                threads.add(thread)
            }

            // Wait for all threads in this group to complete
            threads.each { it.join() }

            // Report group results
            group.each { config ->
                def label = config.loader + ' ' + config.version
                if (passed.contains(label)) {
                    logger.lifecycle("    PASSED: ${label}")
                }
            }
            group.each { config ->
                def label = config.loader + ' ' + config.version
                def failEntry = failed.find { it.startsWith(label) }
                if (failEntry) {
                    logger.error("    FAILED: ${failEntry}")
                }
            }
        }

        // Clean up parallel build directories in root and all subdirectories
        // that contain build.gradle (i.e., all subprojects)
        def dirsToClean = [projectDir]
        projectDir.eachDir { dir ->
            if (new File(dir, 'build.gradle').exists()) {
                dirsToClean.add(dir)
            }
        }
        dirsToClean.each { dir ->
            dir.eachFile { file ->
                if (file.isDirectory() && file.name.startsWith('build-')) {
                    file.deleteDir()
                }
            }
        }

        logger.lifecycle('')
        logger.lifecycle('====================================================')
        logger.lifecycle('GameTest Summary:')
        logger.lifecycle('====================================================')

        passed.sort().each { label ->
            logger.lifecycle("   PASSED: ${label}")
        }
        failed.sort().each { entry ->
            logger.lifecycle("   FAILED: ${entry}")
        }

        logger.lifecycle('')
        logger.lifecycle("Total: ${passed.size()} passed, ${failed.size()} failed")
        logger.lifecycle("Logs: ${logDir.absolutePath}/gametest-*.log")
        logger.lifecycle('====================================================')
        logger.lifecycle('')

        if (!failed.isEmpty()) {
            throw new GradleException("GameTests failed for: ${failed.collect { it.split(' \\(')[0] }.join(', ')}")
        }
    }
}
